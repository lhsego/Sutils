% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bootStrap.R
\name{bootStrap}
\alias{bootStrap}
\title{Generate and calculate statistics from bootstrap samples}
\usage{
bootStrap(testData, calcFun, seed = NULL, n = 1, nJobs = 1,
  summarizeFun = NULL)
}
\arguments{
\item{testData}{A dataframe that will be bootstrapped, must have a column called \code{signatureID}}

\item{calcFun}{a character vector of functions that calculate a particular quality metric
on \code{testData}. See 'Details.'}

\item{seed}{An integer value that sets the seed of the random number generator
for repeatibility.  If \code{NULL}, the seed is chosen by R based on the
system time.}

\item{n}{An integer indicating the number of bootstrap replicates to calculate.}

\item{nJobs}{The number of parallel jobs that will be run using \code{\link{mclapply}}.}

\item{summarizeFun}{a character vector of the names of summary functions that
take a vector of data and compute a SCALAR summary statistic.  E.g., \code{\link{mean}},
\code{\link{median}}, \code{\link{sd}}, etc. Additional arguments to these functions
are currently not supported.  Defaults to \code{NULL}, in which case no summaries of
the bootstrapped samples are calculated.}
}
\value{
A data frame containing of the results calculated by the functions in \code{calcFun},
one row for each \code{signatureID}, with a column indicating the
bootstrap sample if bootstrapping was requested.  If one or more
summary functions (via \code{summarizeFun})
were indicated, then \code{\link{bootStrap}} returns a list, where each element of the list is a dataframe
of the requested scores, summarized across the bootstraps for each \code{signatureID}.
}
\description{
Generate and calculate statistics from bootstrap samples of the test data
}
\details{
Sampling is performed with replacement, stratified by signature ID. The indexes of \code{testData}
that indicate each bootstrap sample are created by \code{\link{genBootstrapIndexes}}.

The functions indicated in \code{calcFun} should each have a single argument
that operate on the entirety of
\code{testData} to calculate some selection of fidelity, scoring, utility, or
summary metrics for each \code{signatureID}. That is, they will produce a single
row of output for each \code{signatureID}, with the metrics on the columns.
These functions will be applied to each bootstrap replicate of \code{testData}, and
they must produce conformable output, i.e., they must
return data frames with the same number of rows, each returned data frame
must have a single column \code{signatureID}, and remaining columns should
ideally be named uniquely across the set of functions.
}
\examples{

data(exampleScoreData)

# Now calculate the scores on the whole data set
e1 <- bootStrap(exampleScoreData, scoreMethods(), n = 2, nJobs = 2)
print(e1)
          
e2 <- bootStrap(exampleScoreData, scoreMethods(), n = 2, nJobs = 2, seed = 283)
e3 <- bootStrap(exampleScoreData, scoreMethods(), n = 2, nJobs = 2, seed = 283)
e4 <- bootStrap(exampleScoreData, scoreMethods(), n = 2, nJobs = 2)

# Should be different
identical(e1, e2)
# Should be the same
identical(e2, e3)
# Should be different
identical(e3, e4)

# Get bootstrap estimates and calculate some summary stats on those bootstrap estimates
e5 <- bootStrap(exampleScoreData, "logScore", n = 6, seed = 3913, 
                summarizeFun = c("mean", "max", "min", "sd"))
print(e5)

# Check the results of summarizing e5
e6 <- bootStrap(exampleScoreData, "logScore", n = 6, seed = 3913)
e6.mean <- list2df(by(e6, e6$signatureID, function(x) c(logScore = mean(x$logScore),
                                                        information = mean(x$information))))
# Manipulate e5.mean a bit for comparison with e6.mean
e5.mean <- e5$mean
rownames(e5.mean) <- e5.mean$signatureID

# Should be identical
identical(e5.mean[, -1], e6.mean)

# Try it using 'calcScore'
cScore <- function(X) calcScore(X, scale = FALSE)
bootStrap(exampleScoreData, "cScore", n = 2, summarizeFun = c("mean","max"))

# An example using a multiAttribute utility function

# Generate single attribute utility functions
sa.funs <- list(a1 = saUtil(theta = 2, zrange = c(-2, 4), urange = c(1, 0)),
                a2 = saUtil(urange = c(1,0), theta = -1.7))
# The weights
alphas <- c(a2 = 0.2, a1 = 0.8)

# Cook up some data
someData <- data.frame(signatureID = rep(c("A", "B"), each = 5),
                       a1 = runif(10, -2, 4),
                       a2 = rpois(10, 3), row.names = letters[1:10],
                       weights = rep(1:5, 2))

# Create a utility function
eu <- function(d) calcExpectedUtil(d, maUtil(alpha = alphas, saUtilFun = sa.funs),
                                   weights = "weights")

# Bootstrap results
bootStrap(someData, "eu", n = 3)

# Look at means and standard deviations
bootStrap(someData, "eu", n = 3, summarizeFun = c("mean", "sd"))
}
\author{
Landon Sego
}

