% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calcExpectedUtil.R
\name{calcExpectedUtil}
\alias{calcExpectedUtil}
\title{Calculate expected utility for each signature}
\usage{
calcExpectedUtil(testData, utilFun, integrandLabel = "utility",
  outputLabel = "expectedUtility", weights = NULL)
}
\arguments{
\item{testData}{A data frame containing attributes used to distinguish
the signature systems on the columns
and observations on the rows. If \code{testData} has column called \code{signatureID},
the expected utility is calculated separately for each \code{signatureID}.}

\item{utilFun}{A function whose single argument is a data frame that calculates
the integrand (typically multiattribute utility)
for each row in the data frame and adds a column
called \code{integrandLabel} containing the value to be integrated to \code{testData}.
This function should be aware of the format and column names of \code{testData}.}

\item{integrandLabel}{The name of the variable added to \code{testData} by \code{utilFun} that
contains the integrand.}

\item{outputLabel}{A character string giving the name of the output column that will be
added to \code{testData} that contains the expected value for each \code{signatureID}.}

\item{weights}{A numeric vector of non-negative values that approximate the joint
distribution of all the variables over which the expected utility will be calculated.
\code{weights} should have the same number of elements as the number of rows in
\code{testData}.
Alternatively, this can be a character string indicating the name of a column in \code{testData} which
contains the weights. If \code{NULL}, equal weight is given to each observation.}
}
\value{
A data frame with the expected utility calculated for each \code{signatureID}
}
\description{
Calculate the expected utility (or other function) for each signature
}
\details{
Weights are normalized for each \code{signatureID}.
}
\examples{
# Generate single attribute utility functions
sa.funs <- list(a1 = saUtil(theta = 2, zrange = c(-2, 4), urange = c(1, 0)),
                a2 = saUtil(urange = c(1,0), theta = -1.7))
# The weights
alphas <- c(a2 = 0.2, a1 = 0.8)

# Cook up some data
someData <- data.frame(signatureID = rep(c("A", "B"), each = 5),
                       a1 = runif(10, -2, 4),
                       a2 = rpois(10, 3), row.names = letters[1:10],
                       weights = rep(1:5, 2))

# Create a utility function
uf <- maUtil(alpha = alphas, saUtilFun = sa.funs)

calcExpectedUtil(someData, uf, weights = "weights")
}
\author{
Landon Sego
}

