% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/addMultUtil.R
\name{addMultUtil}
\alias{addMultUtil}
\title{An additive or multiplicative utility function}
\usage{
addMultUtil(alpha, saUtilFun = NULL, Z = NULL, beta = NULL,
  utilLabel = "utility")
}
\arguments{
\item{alpha}{A named list or named vector containing the weights for the multiattribute
utility function. The names should be the same as \code{saUtilFun}}

\item{saUtilFun}{A named list where each element of which contains its corresponding
single attribute utility function. See Details.}

\item{Z}{A dataframe or matrix containing the values of the attributes, where the attributes
are on the columns and the observations are on the rows.}

\item{beta}{A numeric value for the normalizing constant. If not provided, a solution for
\code{beta} is calculated from the \code{alpha} vector.}

\item{utilLabel}{Character string indicating the column name that will be used for the utility}
}
\value{
If \code{Z = NULL}, the normalizing constant, beta, is returned.  Otherwise, a data frame
of \code{Z} is returned with an additional column called \code{utilLabel} which contains
the additive or multiplicative multiattribute utility, is calculated for each row of
\code{Z}.
}
\description{
An additive or multiplicative utility function
}
\details{
The additive function is used if \code{sum(alpha) == 1} and the
multiplicative function is used otherwise.

Regarding \code{saUtilFun}:  The names of \code{saUtilFun} must be a subset of the names
in \code{Z}, so that each single attribute utility function is matched to its corresponding
attribute in \code{Z}. Each element of \code{saUtilFun} must be of class \code{saUtilFun}.

Functions of this \code{saUtilFun} class take a vector of attribute values as their principal argument and
return a corresponding vector of utility values. They may have additional named agruments that control the
parameters of the single attribute utility function.  They also have the following attributes:
\itemize{
\item{saUtilMethod}{Character string indicating the name of the single attribute utility method}
\item{parms}{A named list of all the agruments and their values that were provided to the call of the
to the single attribute utility function.}
}
See \code{\link{logUtil}} for an example.
}
\examples{
# Generate single attribute utility functions
a1Fun <- saUtil(theta = 2, zrange = c(-2, 4), urange = c(1, 0))
plot(a1Fun)

a2Fun <- saUtil(urange = c(1,0), theta = -1.7)
plot(a2Fun)

# Put them in a single list
sa.funs <- list(attribute1 = a1Fun, attribute2 = a2Fun)

# The weights
alphas <- c(attribute2 = 0.2, attribute1 = 0.8)

# Cook up some data
someData <- data.frame(attribute1 = runif(10, -2, 4),
                       attribute2 = rpois(10, 3), row.names = letters[1:10])

# Calculate the utility
u <- addMultUtil(alphas, saUtilFun = sa.funs, Z = someData)
print(u)

# Manually calculate to check ...
u1 <- saUtil(z = someData$attribute1, theta = 2, zrange = c(-2, 4), urange = c(1, 0))
u2 <- saUtil(z = someData$attribute2, urange = c(1, 0), theta = -1.7)

u.check <- alphas["attribute1"] * u1 + alphas["attribute2"] * u2

# Should be 0
max(abs(u$utility - u.check))

# Now try a check of the multiplicative version
alphas <- c(attribute1 = 0.2, attribute2 = 0.9)
u <- addMultUtil(alphas, saUtilFun = sa.funs, Z = someData)
u.check <- alphas[1] * u1 + alphas[2] * u2 +
           attributes(u)$parms$beta * alphas[1] * alphas[2] * u1 * u2

# Should be 0 (or very close)
max(abs(u$utility - u.check))
}
\author{
Landon Sego
}
\references{
TODO:  finish these references
Keeney & Raifa. Decision... 1976.  Holmes A., Sego L.H., etc. PNNL Technical report 2013
}

