% Generated by roxygen2 (4.0.2): do not edit by hand
\name{n2.vs.viable.lambda.1}
\alias{n2.vs.viable.lambda.1}
\title{Verify the algorithm for finding the viable pct.clean}
\usage{
n2.vs.viable.lambda.1(conf, n1, r, beta, pct.clean, maxN,
  decimal.precision = 5, start.low.pct.clean = FALSE, show.plot = FALSE,
  seq.length = 100, verbose = FALSE, print.deviations = FALSE)
}
\arguments{
\item{conf}{Desired (nominal) confidence level.}

\item{n1}{Number of judgmental samples}

\item{r}{Ratio of prior expecation between judgmental and random samples}

\item{beta}{Second shape pararments of the beta prior of the judgmental
samples}

\item{pct.clean}{The nominal pct.clean for the given case.  This will be
used as the starting value for \code{lambda} if \code{start.low.pct.clean =
FALSE}.}

\item{maxN}{A large integer indicating the transition from finite population
to infinite population formulas.}

\item{decimal.precision}{The precision of the solution for \code{lambda}
(passed to \code{\link{find.viable.lambda}}).}

\item{start.low.pct.clean}{\code{=TRUE} using a starting value of
\code{lambda = 0.80} when searching for the viable \code{lambda}.
Otherwise, it uses \code{lambda = pct.clean}.}

\item{show.plot}{\code{=TRUE} displays a plot of the \code{n2} versus the
viable \code{lambda}}

\item{seq.length}{Integer specifying the length of the \code{n2} sequence
that will be tested}

\item{verbose}{\code{=TRUE} prints all the details of the validation.}

\item{print.deviations}{\code{=TRUE} prints the full output of
\code{\link{minimum.viable.lambda}} if any of the larger \code{lambda}
values are not viable.}
}
\value{
A list with the following elements: \item{n2.0.viable}{The
\code{use.pct.clean} element returned by \code{\link{find.n2.viable}}.}
\item{first.high}{\code{=TRUE} if the viable \code{lambda} required when
\code{n2=0} results in the largest viable \code{lambda} over the sequence of
\code{n2} values.} \item{all.n2.work}{\code{=TRUE} if the viable
\code{lambda} required by \code{n2=0} is also viable for all other \code{n2}
in the sequence} \item{non.incr.seq}{\code{=TRUE} if the resulting viable
\code{lambda} sequence is a non-increasing function of the \code{n2}
sequence, i.e., as \code{n2} increases, the required viable \code{lambda} is
decreasing (or the same).} \item{max.vl.diff}{The largest difference in the
viable lambda sequence.  This will be 0 or negative for non-increasing
sequences.  But it will be positive for a sequence which has an increasing
element} \item{pct.not.decreasing}{The percentage of the \code{n2} sequence
that does not result in decreasing values of viable \code{lambdas}.}
\item{first.index.not.decreasing}{The first index in the \code{n2} sequence
where a non-decreasing viable \code{lambda} occurs}
\item{num.of.greater.viable.lambda.checked}{The number of \code{n2}'s that
were checked using \code{\link{minimum.viable.lambda}}}
\item{all.greater.lambda.viable}{This and the following elements in this
list contain summaries from calls to \code{minimum.viable.lambda} for each
\code{n2}.  This element will be \code{TRUE} if the value \code{all.viable}
returned by \code{\link{minimum.viable.lambda}} is \code{TRUE} for all
\code{n2}.} \item{pct.greater.lambda.viable}{The percentage of \code{n2}
values where the value \code{all.viable} returned by
\code{\link{minimum.viable.lambda}} were \code{TRUE}.}
\item{first.index.not.greater.lambda.viable}{The first index in the
\code{n2} sequence where not all the greater lambdas where viable}
\item{summary.pct.glv.min}{The minimum (across the \code{n2} sequence) of
the \code{pct.viable} value returned by \code{\link{minimum.viable.lambda}}}
\item{summary.pct.glv.q1}{The first quartile (across the \code{n2} sequence)
of the \code{pct.viable} value returned by
\code{\link{minimum.viable.lambda}}} \item{summary.pct.glv.med}{The median
(across the \code{n2} sequence) of the \code{pct.viable} value returned by
\code{\link{minimum.viable.lambda}}} \item{summary.pct.glv.mean}{The mean
(across the \code{n2} sequence) of the \code{pct.viable} value returned by
\code{\link{minimum.viable.lambda}}} \item{summary.pct.glv.q3}{The third
quartile (across the \code{n2} sequence) of the \code{pct.viable} value
returned by \code{\link{minimum.viable.lambda}}}
\item{summary.pct.glv.max}{The maximum (across the \code{n2} sequence) of
the \code{pct.viable} value returned by \code{\link{minimum.viable.lambda}}}
\item{results}{A data frame with a row for each \code{n2} value that gives
the complete (unsummarized) results}
}
\description{
Emprically verifies that \code{n2 = 0} produces the highest viable value of
\code{lambda} for "all" other values of \code{n2}.  Using
\code{\link{minimum.viable.lambda}}, it also checks that \code{lambda}
values larger than the identified viable \code{lambda} are also viable.
}
\details{
This function is nearly identical to \code{\link{n2.vs.viable.lambda}}
except that it does continue testing all \code{n2} in the sequence, even
when the \code{n2} vs. \code{lambda} profiles 'flatlines,' whereas
\code{\link{n2.vs.viable.lambda}} stops testing after 10 consecutive
\code{n2} values that result in the \code{viable.lambda} being equal to the
\code{target.lambda}.

For this function, if the \code{viable.lambda} that is returned for a
particular \code{n2} is equal to the \code{target.lambda}, then
\code{\link{minimum.viable.lambda}} is not called for that \code{n2},
whereas \code{\link{minimum.viable.lambda}} is always called in
\code{\link{n2.vs.viable.lambda}}.

This function examines the fundamental assumptions of the algorithm used by
\code{\link{find.viable.lambda}} and \code{\link{find.n2}} in order to
identify the viable \code{lambda}.  This emperically demonstrates that using
\code{\link{find.viable.lambda}} with \code{n2 = 0} results in the largest
possible viable \code{lambda} value which is also viable for "all" other
\code{n2} values.

It examines a suitably long sequence of \code{n2} values with length
\code{seq.length}. The viable \code{lambda} is calculated for each of the
\code{n2} values, using \code{\link{find.viable.lambda}}. The results of
summarized across the \code{n2} sequence.  As increasinlyg larger values of
\code{n2} are examined, if the value of the resulting viable \code{lambda}
drops below the requested \code{pct.clean} or \code{0.80} (depending on the
value of \code{start.low.pct.clean}) more than 10 consecutive times, the
larger values of \code{n2} are not considered by breaking the loop over the
\code{n2} sequence.

This function also calls \code{\link{minimum.viable.lambda}} for each
\code{n2} value, with results summarized across the \code{lambda} values
higher than the viable \code{lambda} and the \code{n2} sequence.
}
\examples{
n2.vs.viable.lambda.1(0.95, 10, 2, 239, 0.977, 10^6, start.low.pct.clean=TRUE)
}
\author{
Landon Sego
}
\seealso{
\code{\link{find.viable.lambda}}, \code{\link{is.viable.lambda}}
}
\keyword{misc}

